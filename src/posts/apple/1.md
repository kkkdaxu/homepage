---
icon: pen-to-square
date: 2022-01-01
category:
  - 苹果
tag:
  - 红
  - 大
  - 圆
---
# C++重点题目qqqwwww

## ----------------

## 1. (高频)如何看待c++和c的关系

***考点解析***

考察宏观上对c语言和c++特性的了解，回答中要讲清楚c++和c的关系。在宏观上答完区别和联系*（展示自己知识的广度）*，后可以在具体点上进行展开*（展示自己的知识点的深度）*。

> *(首先从宏观回答优缺点，先 1.历史发展，然后 2.和 3.一起说明)*
>
> - C++ 和 C 之间的关系可以从几个不同的角度来理解：
>
> 1. **历史发展**：C++ 最初是作为 **C 语言的一个扩展**被设计的。1979 年开始开发一种名为 "C with Classes" 的新语言，其目的是在 C 语言的基础上增**加对面向对象编程的支持。**随后，这种语言发展成为今天我们所知的 C++。因此，C++ 在很大程度上是基于 C 语言，并保留了 C 语言的许多特性。如：区块，语句，预处理器，内置数据类型，数组，指针等特性都是来自于C。
> 2. **语法和兼容性**：C++ 保留了 C 语言的大部分语法，并增加了**类、异常处理、重载运算符和模板等特性**。C++ 是向后兼容 C 语言的，这意味着大多数合法的 C 程序也是合法的 C++ 程序，尽管有一些例外。
> 3. **设计哲学**：虽然 C++ 保留了 C 的许多特性，但它引入了**面向对象编程**和**泛型编程**的概念，这是 C 所没有的。**C++ 提供了更多的抽象层次，允许开发者以更加模块化和可重用的方式来构建复杂的系统**。
> 4. **使用场景**：**C 语言通常用于系统编程、嵌入式系统和其他需要直接硬件访问的领域**。而 C++，凭借其面向对象的特性，**更适合用于需要高级抽象的大型软件项目，如桌面应用程序、游戏开发和复杂的计算系统。**
> 5. **性能和效率**：C 和 C++ 都是高效率的语言，它们提供了对底层资源的直接控制。但由于 C++ 提供了更多的特性和抽象，它的编译器可能更加复杂，有时可能会对性能产生轻微的影响。
>
> 总的来说，C++ 是在 C 的基础上发展起来的一种更为复杂和强大的语言，它扩展了 C 的功能，同时保留了与 C 的兼容性。尽管两者有很多共同点，但 C++ 提供了更多的编程范式和特性，使得它更适合于大型和复杂的软件项目。

`<u>`对 2. 语法兼容性的进一步阐述 `</u>`

C++ 保留了 C 语言的语法并且通常是向后兼容的，这意味着大多数合法的 C 代码都可以在 C++ 环境中编译和运行。这包括像 OpenGL 这样的库，它们的接口通常是用 C 语言编写的，但可以无缝地在 C++ 项目中使用。

在 OpenGL 的情况下，当您使用像 `glad.c` 这样的扩展加载库时，尽管它是用 C 语言编写的，但它也可以**被 C++ 编译器正常编译和链接**。这是因为 C++ 具有处理 C 语言代码的能力，特别是当它涉及到像 OpenGL 这样的库时，这些库被设计为与 C 和 C++ 兼容。

在实际应用中，C++ 项目经常会使用纯 C 语言编写的库，这是完全可行的。不过，需要注意的是，尽管 C++ 与 C 在很大程度上兼容，但在某些特定情况下可能会出现不兼容的情况。例如，某些特定的**语言特性或编程模式**在 C 中是合法的，但在 C++ 中可能不是，或者反之。因此，在混合使用 C 和 C++ 代码时，仍需注意这些潜在的不兼容性的问题。

在混合使用 C 和 C++ 代码时，确实需要注意某些潜在的不兼容性问题。尽管 C++ 设计上是 C 的一个超集，但在实践中，有一些特定的区别和不兼容性需要考虑：

1. **关键字和名称空间**：

   - C++ 引入了一些新的关键字（如 `class`、`new`、`delete`、`this` 等），这些在 C 中不是保留字。如果 C 代码中恰巧使用了这些作为标识符，它在 C++ 中将不再合法。
   - C++ 使用名称空间（`namespace`），而 C 没有这个概念。
2. **类型检查更加严格**：

   - C++ 对类型的检查更加严格。例如，C 中可以隐式地将 `void*` 转换为其他类型的指针，而在 C++ 中这需要显式转换。
   - 函数重载在 C++ 中是合法的，但 C 中没有函数重载的概念。
3. **结构体和类的差异**：

   - 在 C 中，使用结构体时不需要 `struct` 关键字，而在 C++ 中则必须使用 `class` 或 `struct` 关键字。
   - C++ 中的结构体可以包含函数和访问修饰符（如 `public`、`private`），而 C 中的结构体不支持这些功能。
4. **默认函数参数**：

   - C++ 支持默认函数参数，而 C 不支持。
5. **变量声明**：

   - 在 C 中，变量必须在代码块（如函数）的开始部分声明，而在 C++ 中，变量可以在代码块中的任何地方声明。
6. **==链接规范（Linkage）：==**

   - C 和 C++ 的链接（名字改编或名称修饰）**规则**不同。这意味着由 C 编写的函数和由 C++ 编写的函数在编译后的二进制层面上可能有不同的表示。为了在 C++ 中调用 C 代码，通常需要在 C++ 代码中使用 `extern "C"` 声明来防止名称修饰。

这些差异可能导致在将 C 代码直接用于 C++ 项目时出现编译错误或行为上的差异。因此，在混合使用 C 和 C++ 时，开发者需要对这些潜在的不兼容点有所了解和注意。通常，对于大型项目或库，最佳实践是明确区分 C 和 C++ 代码，并确保在接口层面上正确处理这些差异。

### 1.1 （扩展）如何在C++代码中使用c语言的代码

> 在 C++ 中使用 C 语言代码是一种常见的做法，尤其是在需要利用现有的 C 语言库或代码时。C++ 与 C 兼容，但有一些规则需要遵守，以确保 C 代码能够正确地在 C++ 程序中编译和运行。
>
> ### 使用 C 代码的方法
>
> 1. **外部链接声明（extern "C"）**：
>
>    - C++ 提供了 `extern "C"` 来指示编译器这部分代码是 C 语言编写的。这是因为 C++ 对函数名进行了修饰（name mangling），而 C 语言没有。
>    - 通过使用 `extern "C"`，可以告诉 C++ 编译器不要对这部分代码进行名字修饰，从而使得 C++ 代码能够调用 C 语言编写的函数。
>    - 通常，您可以将 C 代码的函数原型放在 `extern "C"` 块中。
>
>    ```cpp
>    extern "C" {
>        #include "some_c_library.h"
>    }
>    ```
>
>    - 如果你在 C++ 中定义了一个函数，希望它能够被 C 代码调用，也可以使用 `extern "C"`。
>
>    ```cpp
>    extern "C" void myFunction() {
>        // C++ 中定义的函数
>    }
>    ```
> 2. **包含 C 头文件**：
>
>    - 当包含一个纯 C 语言编写的头文件时，应使用 `extern "C"` 来防止名字修饰。
>    - 对于既能被 C 又能被 C++ 包含的头文件，通常在头文件中使用宏来判断是否需要 `extern "C"`。
>
>    ```c
>    // 在 C 头文件中
>    #ifdef __cplusplus
>    extern "C" {
>    #endif
>
>    // C 语言的函数声明
>
>    #ifdef __cplusplus
>    }
>    #endif
>    ```
>
> ### 注意事项
>
> - **类型兼容**：虽然 C 和 C++ 在许多基本类型上是兼容的，但在结构体、类和模板等方面存在差异。确保在 C++ 中使用的 C 类型是兼容的。
> - **内存管理**：C++ 的内存管理（如使用 `new` 和 `delete`）和 C 的内存管理（使用 `malloc` 和 `free`）是不同的。不要混用这两种内存管理方式。
> - **异常处理**：C 语言没有异常处理机制。如果 C 函数通过指针参数返回错误状态，在 C++ 中调用这些函数时需要注意异常安全性。
> - **命名冲突**：由于 C++ 支持函数重载，而 C 不支持，所以在混合使用时要注意避免潜在的命名冲突。
>
> ### 总结
>
> 在 C++ 代码中使用 C 语言代码主要涉及到**对外部链接的处理**（`extern "C"`）和对类型兼容性的考虑。正确地混合使用 C 和 C++ 可以让你充分利用两种语言的优势，但需要注意它们在内存管理、异常处理和类型系统方面的不同。

## ----------------

## 🏅🏅🏅2. (高频)智能指针相关内容

[大丙 智能指针](https://subingwen.cn/cpp/shared_ptr/)

*在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成**内存泄露**。*

“ *C++里边呢我们动态的去申请内存，比如说通过new去申请一块内存，就必须通过delete去销毁。如果说呢咱们通过malloc去申请了内存，那么就需要通过这个free去释放内存。这两种方式之间的区别呢，**是使用new它能够调用构造函数，使用delete呢能自动的调用结构函数**。如果使用malloc和free呢，这个构造和析构呢都不会自动调用。* ”

解决这个问题最有效的方法是使用**智能指针**（smart pointer）。智能指针是**存储指向动态分配（堆）对象指针**的类，用于生存期的控制，**能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露**。

智能指针的核心实现技术是**引用计数**，记录了当前的这块内存被多少个智能指针共同管理着，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。如果引用计数为1，也就是说只有自己管理了这块内存吧，这种情况下，当当前的指针被析构的时候，它会先析构掉管理的这块内存，然后呢自己再析构，这就是智能指针它帮助我们去释放内存的工作原理。

关于这些智能指针类，它们都是模板类型，因为我们实际在操作的时候，也不知道他要管理的指针到底是什么类型，我们只能够在使用的时候，通过这个模板参数，把实际的指针的类型传进去，然后他就可以在内部帮助我们进行管理了。

### 2.1 （高频）讲一下什么是智能指针/智能指针有哪几种

> 相比于裸指针，智能指针是对裸指针的一种封装，初衷是让程序员b。常见的智能指针有 `auto_ptr（已废弃）,  unique_ptr,  shared_ptr, weak_ptr`。

### 2.2 （高频）讲一下这几种智能指针的区别和优缺点

> 1. `auto_ptr`的在c++11中就已经标为废弃了，取而代之的是 `unique_ptr`, 相比之下，`unique_ptr`语义更加清晰，更加安全，不允许复制，更加高效，并且更好地支持数组，以及c++11的特性等，因此 `auto_ptr`就已经被废除。
> 2. `Weak_ptr`本身不具备内存管理地能力，它主要是为了解决 `shared_ptr`可能导致的循环引用的问题。`Weak_ptr`的原理就是指向某个资源时，但它不会增加这个资源的引用计数。
>
> ##### 因此，实际上真正意义上的智能指针就是 `unique_ptr`和 `shared_ptr`
>
> 3. `unique_ptr`是独占的智能指针,最主要的特点就是对资源是**独占的**, 它不可以复制。它通过**在析构函数中释放资源**来管理对象的生命周期，来自动管理资源。可以防止多个智能指针指向同一个对象，更加方便于管理。相比 `shared_ptr`它的优点是高效，避免了循环引用的问题。
> 4. `shared_ptr`是共享的智能指针，当一个资源需要在多个对象之间共享时，就无法使用 `unique_ptr`了。这是就需要使用到 `shared_ptr`，它通过引用计数的方式来对资源进行控制，但是它存在**循环引用**的问题，需要结合 `weak_ptr`来避免。

### 2.3 （中频）具体讲一下 `shared_ptr`自动管理内存的原理

/ （中频）*引用计数的具体原理*

/ （中频）*智能指针是如何自动管理资源的？智能指针的核心原理是什么？*

/ （中频）*`shared_ptr`引用计数什么时候会增加，什么时候会减少？*
